"use strict";
// Copyright DataStax, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OperationNotSupportedError = exports.Collection = void 0;
const collection_1 = __importDefault(require("mongoose/lib/collection"));
class Collection extends collection_1.default {
    constructor(name, conn, options) {
        super(name, conn, options);
        this.debugType = 'StargateMongooseCollection';
        this.modelName = options.modelName;
        delete options.modelName;
        this._closed = false;
    }
    get collection() {
        if (this._collection != null) {
            return this._collection;
        }
        this._collection = this.conn.db.collection(this.name);
        return this._collection;
    }
    /**
  * @deprecated
  */
    count(filter) {
        return this.collection.count(filter);
    }
    countDocuments(filter) {
        return this.collection.countDocuments(filter);
    }
    find(filter, options, callback) {
        if (options != null) {
            processSortOption(options);
        }
        const cursor = this.collection.find(filter, options);
        if (callback != null) {
            return callback(null, cursor);
        }
        return cursor;
    }
    findOne(filter, options) {
        if (options != null) {
            processSortOption(options);
        }
        return this.collection.findOne(filter, options);
    }
    insertOne(doc) {
        return this.collection.insertOne(doc);
    }
    insertMany(documents, options) {
        return this.collection.insertMany(documents, options);
    }
    findOneAndUpdate(filter, update, options) {
        if (options != null) {
            processSortOption(options);
        }
        return this.collection.findOneAndUpdate(filter, update, options);
    }
    findOneAndDelete(filter, options) {
        if (options != null) {
            processSortOption(options);
        }
        return this.collection.findOneAndDelete(filter, options);
    }
    findOneAndReplace(filter, newDoc, options) {
        if (options != null) {
            processSortOption(options);
        }
        return this.collection.findOneAndReplace(filter, newDoc, options);
    }
    deleteMany(filter) {
        return this.collection.deleteMany(filter);
    }
    deleteOne(filter, options, callback) {
        if (options != null) {
            processSortOption(options);
        }
        const promise = this.collection.deleteOne(filter, options);
        if (callback != null) {
            promise.then((res) => callback(null, res), (err) => callback(err, null));
        }
        return promise;
    }
    updateOne(filter, update, options) {
        if (options != null) {
            processSortOption(options);
        }
        return this.collection.updateOne(filter, update, options);
    }
    updateMany(filter, update, options) {
        return this.collection.updateMany(filter, update, options);
    }
    bulkWrite(_ops, _options) {
        throw new OperationNotSupportedError('bulkWrite() Not Implemented');
    }
    aggregate(_pipeline, _options) {
        throw new OperationNotSupportedError('aggregate() Not Implemented');
    }
    bulkSave(_docs, _options) {
        throw new OperationNotSupportedError('bulkSave() Not Implemented');
    }
    cleanIndexes(_options) {
        throw new OperationNotSupportedError('cleanIndexes() Not Implemented');
    }
    listIndexes(_options) {
        throw new OperationNotSupportedError('listIndexes() Not Implemented');
    }
    createIndex(_fieldOrSpec, _options) {
        throw new OperationNotSupportedError('createIndex() Not Implemented');
    }
    dropIndexes() {
        throw new OperationNotSupportedError('dropIndexes() Not Implemented');
    }
    watch() {
        throw new OperationNotSupportedError('watch() Not Implemented');
    }
    distinct() {
        throw new OperationNotSupportedError('distinct() Not Implemented');
    }
    estimatedDocumentCount() {
        throw new OperationNotSupportedError('estimatedDocumentCount() Not Implemented');
    }
    replaceOne() {
        throw new OperationNotSupportedError('replaceOne() Not Implemented');
    }
    syncIndexes() {
        throw new OperationNotSupportedError('syncIndexes() Not Implemented');
    }
}
exports.Collection = Collection;
function processSortOption(options) {
    if (options.sort == null) {
        return;
    }
    if (typeof options.sort.$vector !== 'object' || Array.isArray(options.sort.$vector)) {
        return;
    }
    options.sort.$vector = options.sort.$vector.$meta;
}
class OperationNotSupportedError extends Error {
    constructor(message) {
        super(message);
        this.name = 'OperationNotSupportedError';
    }
}
exports.OperationNotSupportedError = OperationNotSupportedError;
//# sourceMappingURL=collection.js.map